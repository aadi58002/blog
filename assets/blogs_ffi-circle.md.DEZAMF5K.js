import{_ as t,c as r,l as e,a as i,t as n,a5 as o,o as l,a8 as s}from"./chunks/framework.D7ootnaT.js";const w=JSON.parse('{"title":"Foreign Function Interface are hard","description":"A fun learning project to learn about ffi between languages and tooling around them","frontmatter":{"title":"Foreign Function Interface are hard","description":"A fun learning project to learn about ffi between languages and tooling around them","production":true,"tags":["Programming","Fun","FFI"]},"headers":[],"relativePath":"blogs/ffi-circle.md","filePath":"blogs/ffi-circle.md","lastUpdated":1724329409000}'),h={name:"blogs/ffi-circle.md"},c={id:"frontmatter-title",tabindex:"-1"},u=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),d=o('<p><img src="'+s+'" alt="Banner Image"></p><nav class="table-of-contents"><ul><li><a href="#what">What?</a></li><li><a href="#code">Code</a></li><li><a href="#calling-functions">Calling Functions</a><ul><li><a href="#within-same-languages">Within Same languages</a></li><li><a href="#different-languages">Different languages</a></li><li><a href="#dso-error">DSO Error</a></li></ul></li></ul></nav><h2 id="what" tabindex="-1">What? <a class="header-anchor" href="#what" aria-label="Permalink to &quot;What?&quot;">​</a></h2><p>So what are we trying to do today?<br> Let&#39;s spice up the process of calling a function by passing it between different programming languages, and then back to the original one, while we are at it lets learn about Foreign Function Interface (ffi).</p><h2 id="code" tabindex="-1">Code <a class="header-anchor" href="#code" aria-label="Permalink to &quot;Code&quot;">​</a></h2><p>I have tried to keep the commit message as descriptive as possible with each containing the problem and the solution. I recommend you go through the repo commit by commit and try to run the code yourself as well.</p><p>Linux has great tools to poke around in <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noreferrer">ELF Files</a> (Executable and Linkable Format).</p><p>Some common Tools we will be using readelf, nm, ldd, objdump.</p><p>Github Repo -&gt; <a href="https://github.com/aadi58002/ffi-circle" target="_blank" rel="noreferrer">ffi-circle</a></p><h2 id="calling-functions" tabindex="-1">Calling Functions <a class="header-anchor" href="#calling-functions" aria-label="Permalink to &quot;Calling Functions&quot;">​</a></h2><h3 id="within-same-languages" tabindex="-1">Within Same languages <a class="header-anchor" href="#within-same-languages" aria-label="Permalink to &quot;Within Same languages&quot;">​</a></h3><p>Usually calling a function in a languages is a trivial task. You just have to tell the languages where the function is and it will call that for you.<br> Function call alone is a very large subject and this entire blog can be about this topic but it is better left to those who understand it <a href="https://fasterthanli.me/series/reading-files-the-hard-way/part-2" target="_blank" rel="noreferrer">better</a>. <br><br> In hindsight we don&#39;t need all the details just the below topics will be enough.</p><ol><li>Static libraries vs dynamic libraries</li><li>Compiler steps (Primarily Linking step)</li></ol><div class="tip custom-block"><p class="custom-block-title">Resources</p><ul><li><a href="https://fasterthanli.me/series/making-our-own-executable-packer/part-5" target="_blank" rel="noreferrer">Fasterthanlime: Making Our Own Executable Packer (Part 5): The simplest shared library</a></li><li><a href="https://www.akkadia.org/drepper/dsohowto.pdf" target="_blank" rel="noreferrer">How To Write Shared Libraries by Ulrich Drepper</a></li></ul></div><h3 id="different-languages" tabindex="-1">Different languages <a class="header-anchor" href="#different-languages" aria-label="Permalink to &quot;Different languages&quot;">​</a></h3><p>Calling functions from another languages this is where the fun begins.</p><h4 id="rpath" tabindex="-1">rpath <a class="header-anchor" href="#rpath" aria-label="Permalink to &quot;rpath&quot;">​</a></h4><p>Since none of the libraries are statically linked they look for function at runtime with LD_LIBRARY_PATH env variable which is different for c++(../c) -&gt; at c library LD_LIBRARY_PATH should be ../rust but is ../c when calling from c++</p><h4 id="c-name-mangling-and-extern-vs-extern-c" tabindex="-1">C++ name-mangling and extern vs extern &quot;C&quot; <a class="header-anchor" href="#c-name-mangling-and-extern-vs-extern-c" aria-label="Permalink to &quot;C++ name-mangling and extern vs extern &quot;C&quot;&quot;">​</a></h4><p>C++ features bites back again. Since there can be multiple function with same name in c++.c++ compiler does something call name-mangling because change name to uniq indentifier by adding some uniq identifier to it but this breaks the name by which you call a function from at the time of ma</p><h3 id="dso-error" tabindex="-1">DSO Error <a class="header-anchor" href="#dso-error" aria-label="Permalink to &quot;DSO Error&quot;">​</a></h3><ul><li><a href="https://stackoverflow.com/questions/65269574/understanding-linker-error-dso-missing-from-command-line" target="_blank" rel="noreferrer">stackoverflow: Understanding Linker Error: DSO missing from command line</a></li></ul>',22);function f(a,g,m,b,p,_){return l(),r("div",null,[e("h1",c,[i(n(a.$frontmatter.title)+" ",1),u]),d])}const x=t(h,[["render",f]]);export{w as __pageData,x as default};
